<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>POKEMON RED ‚Äî SmokRob üö¨ü§ñ</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root {
    --gb-darkest: #0F380F;
    --gb-dark: #306230;
    --gb-light: #8BAC0F;
    --gb-lightest: #9BBC0F;
    --red-accent: #E03030;
    --bg: #0a0a0a;
    --card-bg: #111811;
    --border: #1a3a1a;
    --text: #9BBC0F;
    --text-dim: #4a6a2a;
    --text-bright: #c0e020;
    --gold: #e0a030;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Press Start 2P', monospace;
    font-size: 10px;
    line-height: 1.8;
    overflow-x: hidden;
  }
  body::after {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.08) 2px, rgba(0,0,0,0.08) 4px);
    pointer-events: none;
    z-index: 9999;
  }

  .header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 20px;
    border-bottom: 2px solid var(--gb-dark);
    background: var(--gb-darkest);
  }
  .header h1 { font-size: 14px; color: var(--text-bright); text-shadow: 0 0 10px rgba(155,188,15,0.5); }
  .header .subtitle { font-size: 8px; color: var(--text-dim); margin-left: 12px; }
  .header .status { font-size: 8px; color: var(--text-dim); }
  .header .status.live { color: var(--gb-lightest); }
  .header .status.live::before { content: '‚óè'; color: var(--red-accent); margin-right: 6px; animation: blink 1s infinite; }
  @keyframes blink { 50% { opacity: 0.3; } }

  .container {
    display: grid;
    grid-template-columns: 480px 1fr;
    grid-template-rows: auto auto 1fr;
    gap: 12px; padding: 12px;
    max-width: 1400px; margin: 0 auto;
    min-height: calc(100vh - 50px);
  }

  .card {
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 12px;
  }
  .card-title {
    font-size: 8px; color: var(--text-dim);
    text-transform: uppercase; letter-spacing: 2px;
    margin-bottom: 10px; padding-bottom: 6px;
    border-bottom: 1px solid var(--border);
  }

  /* Screenshot */
  .screenshot-panel {
    display: flex; align-items: center; justify-content: center;
    background: var(--gb-darkest);
    grid-row: 1 / 3;
  }
  .screenshot-panel img {
    width: 460px; height: auto;
    image-rendering: pixelated;
    border: 3px solid var(--gb-dark);
    border-radius: 2px;
  }
  .screenshot-panel .no-image { color: var(--text-dim); font-size: 9px; text-align: center; }

  /* Quest */
  .quest-panel { font-size: 9px; }
  .quest-name { color: var(--gold); font-size: 10px; margin-bottom: 6px; }
  .quest-step { color: var(--text-bright); margin-bottom: 4px; }
  .quest-hint { color: var(--text-dim); font-size: 8px; }

  /* Party & State */
  .info-panel { font-size: 9px; }
  .state-row { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(26,58,26,0.3); }
  .state-label { color: var(--text-dim); }
  .state-value { color: var(--text-bright); text-align: right; }

  .party-pokemon { padding: 6px 0; border-bottom: 1px solid rgba(26,58,26,0.3); }
  .poke-header { display: flex; justify-content: space-between; margin-bottom: 2px; }
  .poke-name { color: var(--text-bright); }
  .poke-hp { color: var(--text-dim); }
  .poke-moves { color: var(--text-dim); font-size: 7px; margin-top: 2px; }
  .hp-bar-bg { background: var(--gb-darkest); height: 6px; border-radius: 1px; overflow: hidden; border: 1px solid var(--gb-dark); }
  .hp-bar-fill { height: 100%; background: var(--gb-lightest); transition: width 0.5s; }
  .hp-bar-fill.low { background: var(--gold); }
  .hp-bar-fill.critical { background: var(--red-accent); }

  .badge-row { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 4px; }
  .badge {
    width: 16px; height: 16px; border-radius: 2px;
    border: 1px solid var(--gb-dark); background: var(--gb-darkest);
    display: flex; align-items: center; justify-content: center; font-size: 6px;
  }
  .badge.earned { background: var(--red-accent); border-color: #ff5050; color: white; }

  /* Activity feed */
  .feed-panel { grid-column: 1 / -1; max-height: 300px; }
  .feed-scroll { overflow-y: auto; max-height: 260px; scrollbar-width: thin; scrollbar-color: var(--gb-dark) var(--bg); }
  .feed-scroll::-webkit-scrollbar { width: 4px; }
  .feed-scroll::-webkit-scrollbar-track { background: var(--bg); }
  .feed-scroll::-webkit-scrollbar-thumb { background: var(--gb-dark); }

  .feed-entry { padding: 4px 8px; font-size: 8px; border-bottom: 1px solid rgba(26,58,26,0.15); }
  .feed-entry:hover { background: rgba(155,188,15,0.03); }
  .feed-main { display: flex; gap: 10px; align-items: baseline; }
  .feed-turn { color: var(--text-dim); min-width: 36px; }
  .feed-action { min-width: 120px; }
  .feed-action.battle { color: var(--red-accent); }
  .feed-action.navigate { color: #30a0e0; }
  .feed-action.heal { color: #30e070; }
  .feed-action.run { color: var(--gold); }
  .feed-action.move { color: var(--text); }
  .feed-pos { color: var(--text-dim); font-size: 7px; }
  .feed-reasoning { color: #5a8a3a; font-size: 7px; margin-top: 1px; padding-left: 46px; }

  /* Event highlights */
  .feed-entry.highlight { background: rgba(224,48,48,0.08); border-left: 2px solid var(--red-accent); }
  .feed-entry.levelup { background: rgba(224,160,48,0.08); border-left: 2px solid var(--gold); }

  /* Stats bar */
  .stats-panel {
    grid-column: 1 / -1;
    display: flex; gap: 32px; flex-wrap: wrap;
    align-items: center;
  }
  .stat-item { display: flex; flex-direction: column; gap: 4px; }
  .stat-value { font-size: 16px; color: var(--text-bright); text-shadow: 0 0 8px rgba(155,188,15,0.3); }
  .stat-label { font-size: 7px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; }

  /* Waiting */
  .waiting {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    grid-column: 1 / -1; min-height: 400px; text-align: center; gap: 16px;
  }
  .waiting h2 { font-size: 12px; color: var(--text-dim); }
  .waiting .dots::after { content: ''; animation: dots 1.5s infinite; }
  @keyframes dots { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }

  @media (max-width: 900px) {
    .container { grid-template-columns: 1fr; }
    .screenshot-panel { grid-row: auto; }
    .screenshot-panel img { width: 100%; max-width: 460px; }
    .feed-panel, .stats-panel { grid-column: 1; }
  }
</style>
</head>
<body>

<div class="header">
  <div style="display:flex;align-items:baseline;gap:8px">
    <h1>POKEMON RED <span style="color:var(--red-accent)">‚ñ∂</span> AI</h1>
    <span class="subtitle">SmokRob üö¨ü§ñ √ó SMOG the Squirtle</span>
  </div>
  <div class="status" id="connection-status">CONNECTING...</div>
</div>

<div class="container" id="main-container">
  <div class="waiting" id="waiting-screen">
    <h2>WAITING FOR GAME DATA<span class="dots"></span></h2>
    <div style="font-size:8px;color:var(--text-dim)">Start a play session to see live data</div>
  </div>
</div>

<template id="dashboard-template">
  <div class="card screenshot-panel" id="screenshot-card">
    <div class="no-image" id="no-screenshot">CONNECTING TO STREAM...</div>
    <img id="game-screenshot" src="/stream" style="display:block" alt="Game Boy Screen"
         onerror="this.style.display='none';document.getElementById('no-screenshot').style.display='block';"
         onload="document.getElementById('no-screenshot').style.display='none';this.style.display='block';">
  </div>

  <div class="card quest-panel" id="quest-card">
    <div class="card-title">üéØ CURRENT QUEST</div>
    <div class="quest-name" id="q-name">‚Äî</div>
    <div class="quest-step" id="q-step">‚Äî</div>
    <div class="quest-hint" id="q-hint"></div>
  </div>

  <div class="card info-panel" id="info-card">
    <div class="card-title">TRAINER CARD</div>
    <div class="state-row"><span class="state-label">LOCATION</span><span class="state-value" id="s-location">‚Äî</span></div>
    <div class="state-row"><span class="state-label">COORDS</span><span class="state-value" id="s-coords">‚Äî</span></div>
    <div class="state-row"><span class="state-label">BADGES</span><span class="state-value"><span class="badge-row" id="badge-row"></span></span></div>
    <div class="card-title" style="margin-top:12px">PARTY</div>
    <div id="party-list"></div>
  </div>

  <div class="card feed-panel">
    <div class="card-title">ACTIVITY LOG</div>
    <div class="feed-scroll" id="feed-scroll">
      <div id="feed-list"></div>
    </div>
  </div>

  <div class="card stats-panel" id="stats-panel">
    <div class="stat-item"><span class="stat-value" id="stat-decisions">0</span><span class="stat-label">DECISIONS</span></div>
    <div class="stat-item"><span class="stat-value" id="stat-battles">0</span><span class="stat-label">BATTLES</span></div>
    <div class="stat-item"><span class="stat-value" id="stat-kos">0</span><span class="stat-label">KOs</span></div>
    <div class="stat-item"><span class="stat-value" id="stat-level">‚Äî</span><span class="stat-label">HIGHEST LV</span></div>
    <div class="stat-item"><span class="stat-value" id="stat-hp">‚Äî</span><span class="stat-label">PARTY HP</span></div>
    <div class="stat-item"><span class="stat-value" id="stat-maps">0</span><span class="stat-label">MAPS SEEN</span></div>
  </div>
</template>

<script>
const POLL_MS = 1500;
let active = false;
let allEntries = [];
let mapsVisited = new Set();

function activate() {
  if (active) return;
  active = true;
  const c = document.getElementById('main-container');
  const w = document.getElementById('waiting-screen');
  if (w) w.remove();
  c.appendChild(document.getElementById('dashboard-template').content.cloneNode(true));
}

function el(id) { return document.getElementById(id); }

function classifyAction(entry) {
  const a = (entry.action || '').toLowerCase();
  if (a.includes('fight') || a.includes('battle')) return 'battle';
  if (a.includes('navigate') || a.includes('nav')) return 'navigate';
  if (a.includes('heal') || a.includes('go_heal')) return 'heal';
  if (a.includes('run')) return 'run';
  return 'move';
}

function formatAction(entry) {
  const a = entry.action || '‚Äî';
  const cls = classifyAction(entry);
  
  let icon = '‚ñ∂';
  if (cls === 'battle') icon = '‚öîÔ∏è';
  else if (cls === 'navigate') icon = 'üó∫Ô∏è';
  else if (cls === 'heal') icon = 'üíö';
  else if (cls === 'run') icon = 'üèÉ';
  
  let label = a;
  const moveMatch = a.match(/FIGHT move_(\d+)/);
  if (moveMatch) {
    const idx = parseInt(moveMatch[1], 10);
    const moves = entry.party_hp?.[0]?.moves;
    const moveName = moves?.[idx]?.name || moves?.[idx];
    label = moveName && moveName !== '---' ? moveName.toUpperCase() : `MOVE ${idx + 1}`;
  } else if (a.startsWith('NAVIGATE')) label = a;
  else if (a === 'RUN') label = 'RUN AWAY';
  else if (a === 'GO_HEAL') label = 'HEAL UP';
  
  return { icon, label, cls };
}

function isLevelUp(entry, prev) {
  if (!prev || !entry.party_hp || !prev.party_hp) return false;
  const curLv = entry.party_hp[0]?.level;
  const prevLv = prev.party_hp[0]?.level;
  return curLv && prevLv && curLv > prevLv;
}

function updateAll(entries) {
  if (!entries.length) return;
  const latest = entries[entries.length - 1];
  
  // Screenshot ‚Äî MJPEG stream handles this automatically via <img src="/stream">
  // No polling needed for the game screen image
  
  // Location
  const pos = latest.position || {};
  if (el('s-location')) el('s-location').textContent = pos.map_name || '‚Äî';
  if (el('s-coords')) el('s-coords').textContent = pos.x !== undefined ? `(${pos.x}, ${pos.y})` : '‚Äî';
  
  // Track maps
  if (pos.map_name) mapsVisited.add(pos.map_name);
  entries.forEach(e => { if (e.position?.map_name) mapsVisited.add(e.position.map_name); });
  
  // Badges
  const badgeRow = el('badge-row');
  if (badgeRow) {
    const names = ['ü™®','üíß','‚ö°','üåø','‚ò†Ô∏è','üîÆ','üî•','üåç'];
    const labels = ['Boulder','Cascade','Thunder','Rainbow','Soul','Marsh','Volcano','Earth'];
    const earned = latest.badges || {};
    badgeRow.innerHTML = names.map((emoji, i) => {
      const has = earned[labels[i]] || earned[labels[i].toLowerCase()];
      return `<span class="badge${has ? ' earned' : ''}" title="${labels[i]}">${emoji}</span>`;
    }).join('');
  }
  
  // Quest ‚Äî populated by fetchQuest(), skip here
  
  // Party (handles both party_hp from logs and party from server state)
  const partyList = el('party-list');
  const partyData = latest.party_hp || latest.party;
  if (partyList && partyData) {
    partyList.innerHTML = partyData.map(p => {
      const hp = p.hp ?? p.current_hp ?? 0;
      const max = p.max_hp || 1;
      const pct = Math.round((hp / max) * 100);
      const bar = pct <= 20 ? 'critical' : pct <= 50 ? 'low' : '';
      const moves = p.moves ? p.moves.map(m => m.name || m).filter(m => m !== '---').join(', ') : '';
      return `
        <div class="party-pokemon">
          <div class="poke-header">
            <span class="poke-name">${p.name || '???'} Lv${p.level || '?'}</span>
            <span class="poke-hp">${hp}/${max}</span>
          </div>
          <div class="hp-bar-bg"><div class="hp-bar-fill ${bar}" style="width:${pct}%"></div></div>
          ${moves ? `<div class="poke-moves">${moves}</div>` : ''}
        </div>`;
    }).join('');
  }
  
  // Feed
  const feedList = el('feed-list');
  const feedScroll = el('feed-scroll');
  if (feedList) {
    feedList.innerHTML = entries.map((e, i) => {
      const { icon, label, cls } = formatAction(e);
      const num = e.decision || '?';
      const pos = e.position || {};
      const before = e.before || {};
      const posStr = pos.map_name ? `${pos.map_name} (${pos.x},${pos.y})` : '';
      const reasoning = e.reasoning || '';
      const prev = i > 0 ? entries[i-1] : null;
      const lvUp = isLevelUp(e, prev);
      const enemy = e.battle?.enemy;
      const enemyStr = enemy ? ` vs ${enemy.name || '???'} Lv${enemy.level || '?'}` : '';
      
      let highlight = '';
      if (lvUp) highlight = ' levelup';
      else if (cls === 'battle' && e.party_hp?.[0]?.hp <= 5) highlight = ' highlight';
      
      let extraLine = '';
      if (lvUp) extraLine = `<div class="feed-reasoning" style="color:var(--gold)">‚≠ê LEVEL UP! ${e.party_hp[0]?.name} ‚Üí Lv${e.party_hp[0]?.level}</div>`;
      else if (reasoning) extraLine = `<div class="feed-reasoning">üí≠ ${reasoning}${enemyStr}</div>`;
      
      return `
        <div class="feed-entry${highlight}">
          <div class="feed-main">
            <span class="feed-turn">#${num}</span>
            <span class="feed-action ${cls}">${icon} ${label}</span>
            <span class="feed-pos">${posStr}</span>
          </div>
          ${extraLine}
        </div>`;
    }).join('');
    feedScroll.scrollTop = feedScroll.scrollHeight;
  }
  
  // Stats
  let battles = 0, kos = 0, maxLv = 0;
  entries.forEach(e => {
    if ((e.action||'').includes('FIGHT')) battles++;
    if (e.in_battle === false && entries[entries.indexOf(e)-1]?.in_battle) kos++;
    (e.party_hp||[]).forEach(p => { if (p.level > maxLv) maxLv = p.level; });
  });
  
  if (el('stat-decisions')) el('stat-decisions').textContent = entries[entries.length-1]?.decision || entries.length;
  if (el('stat-battles')) el('stat-battles').textContent = battles;
  if (el('stat-kos')) el('stat-kos').textContent = kos;
  if (el('stat-level')) el('stat-level').textContent = maxLv || '‚Äî';
  if (el('stat-maps')) el('stat-maps').textContent = mapsVisited.size;
  
  const hpData = latest.party_hp || latest.party;
  if (el('stat-hp') && hpData?.length) {
    let th = 0, tm = 0;
    hpData.forEach(p => { th += (p.hp||0); tm += (p.max_hp||1); });
    el('stat-hp').textContent = `${Math.round(th/tm*100)}%`;
  }
}

let cachedQuest = null;
let questFetchedAt = 0;

async function fetchQuest() {
  // Re-fetch at most every 10 seconds
  if (cachedQuest && Date.now() - questFetchedAt < 10000) return;
  try {
    const res = await fetch('/api/quest');
    if (!res.ok) return;
    const json = await res.json();
    cachedQuest = json.data;
    questFetchedAt = Date.now();
  } catch (_) {}

  if (!cachedQuest) return;
  const qId = cachedQuest.current_quest;
  const stepIdx = cachedQuest.quest_step;
  const quest = (cachedQuest.quest_log || []).find(q => q.id === qId);
  if (!quest) return;

  const qName = el('q-name');
  const qStep = el('q-step');
  const qHint = el('q-hint');
  if (qName) qName.textContent = quest.name;
  if (qStep && quest.steps[stepIdx]) qStep.textContent = `Step ${stepIdx + 1}: ${quest.steps[stepIdx].desc}`;
  const next = quest.steps[stepIdx + 1];
  if (qHint) qHint.textContent = next ? `Next: ${next.desc}` : 'Final step!';
}

async function poll() {
  const status = el('connection-status');
  try {
    // Fetch server state and history in parallel
    const [stateRes, histRes] = await Promise.all([
      fetch('/api/state'),
      fetch('/api/history?limit=200'),
    ]);
    const stateData = await stateRes.json();
    const histData = await histRes.json();

    if (stateData.status === 'ok' || stateData.data) {
      activate();
      status.textContent = 'LIVE';
      status.className = 'status live';
    }

    const entries = histData.data || [];
    const sd = stateData.data || stateData;

    // Merge live server state into a synthetic "latest" entry so updateAll
    // always has real-time party/badges/position even between logged actions
    if (sd.party) {
      const liveEntry = {
        decision: entries.length ? entries[entries.length - 1].decision : 0,
        position: sd.position,
        party_hp: sd.party.map(p => ({
          name: p.name, hp: p.hp ?? p.current_hp, max_hp: p.max_hp,
          level: p.level, moves: p.moves || [],
        })),
        in_battle: sd.in_battle,
        badges: sd.badges,
        action: '',
      };
      if (entries.length) {
        // Overlay live state onto the last entry
        Object.assign(entries[entries.length - 1], {
          position: liveEntry.position,
          party_hp: liveEntry.party_hp,
          in_battle: liveEntry.in_battle,
          badges: liveEntry.badges,
        });
      } else {
        entries.push(liveEntry);
      }
    }

    if (entries.length) updateAll(entries);
    fetchQuest();
  } catch (err) {
    status.textContent = 'OFFLINE';
    status.className = 'status';
  }
}

setInterval(poll, POLL_MS);
poll();
</script>
</body>
</html>
